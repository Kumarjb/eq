import numpy as np
from datetime import datetime
import pyarrow as pa
from qablet_contracts.timetable import TS_EVENT_SCHEMA

# Defining look-back payoff function
# First we for this project, let's take a look back call
def lookback_pay_fn(inputs):
    [s_max, k] = inputs
    return [np.maximum(s_max - k, 0)]

# Creating a look-back option timetable with monthly lookbacks
def lookback_timetable(ticker, strike, start_date, maturity):
    fix_dates = pd.date_range(start=start_date, end=maturity, freq='M')
    events = [
        {
            "track": "",
            "time": fix_dates[0],
            "op": None,
            "quantity": 0,
            "unit": "INIT",  
        }
    ]
    
    for fixing_time in fix_dates[1:]:
        events.append(
            {
                "track": "",
                "time": fixing_time,
                "op": None,
                "quantity": 0,
                "unit": "UPDATE",  #here we update maximum price every month
            }
        )
    
    # Add FIX event to set the strike price
    events.append(
        {
            "track": "",
            "time": maturity,
            "op": None,
            "quantity": 0,
            "unit": "FIX",  # setting the strike price
        }
    )
    
    events.append(
        {
            "track": "",
            "time": maturity,
            "op": "+",
            "quantity": 1,
            "unit": "LOOKBACK",  # paying look-back
        }
    )

    # Defining the strike phrase, which is a fixed strike price
    def strike_fn(inputs):
        return [strike]

    events_table = pa.RecordBatch.from_pylist(events, schema=TS_EVENT_SCHEMA)
    return {
        "events": events_table,
        "expressions": {
            "LOOKBACK": {
                "type": "phrase",
                "inp": ["MAX_PRICE", "K"],  
                "fn": lookback_pay_fn,
            },
            "UPDATE": {
                "type": "snapper",
                "inp": [ticker, "MAX_PRICE"],
                "fn": lambda inputs: [np.maximum(inputs[0], inputs[1])],
                "out": ["MAX_PRICE"],
            },
            "INIT": {
                "type": "snapper",
                "inp": [ticker],
                "fn": lambda inputs: [inputs[0]],
                "out": ["MAX_PRICE"],
            },
            "FIX": {
                "type": "snapper",
                "inp": [ticker],
                "fn": strike_fn,
                "out": ["K"],
            },
        },
    }



import pandas as pd
from data.spx_2005_09_15 import basic_info, heston_data, localvol_data, rbergomi_data

info = basic_info()
prc_dt = info["prc_dt"]
ticker = info["ticker"]
spot = info["spot"]
strike = spot  # Assuming strike price is the current spot price

# Creating a look-back option timetable
exp_dt = prc_dt + pd.DateOffset(months=6)
timetable = lookback_timetable(ticker, strike, prc_dt, exp_dt)
print(timetable["events"].to_pandas())

# Pricing with Local Volatility Model
from src.model.localvol import LVMCModel

model = LVMCModel()
price, _ = model.price(timetable, localvol_data())
print(f"LocalVol price: {price}")

# Pricing with Rough Bergomi Model
from sr.model.rbergomi import rBergomiMCModel

rbergomi_model = rBergomiMCModel()
dataset = rbergomi_data()
dataset["MC"]["PATHS"] = 20000 
rbergomi_price, _ = rbergomi_model.price(timetable, dataset)
print(f"rBergomi price: {rbergomi_price}")

# Pricing with Heston Model
from qablet.heston.mc import HestonMCModel

heston_model = HestonMCModel()
heston_price, _ = heston_model.price(timetable, heston_data())
print(f"Heston price: {heston_price}")
